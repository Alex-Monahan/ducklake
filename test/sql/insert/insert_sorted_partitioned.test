# name: test/sql/insert/insert_sorted_partitioned.test
# description: test ducklake insert with both partitioning and SET SORTED BY on different columns
# group: [insert]

require ducklake

require parquet

test-env DUCKLAKE_CONNECTION __TEST_DIR__/{UUID}.db

statement ok
ATTACH 'ducklake:${DUCKLAKE_CONNECTION}' AS ducklake (DATA_PATH '__TEST_DIR__/insert_sorted_partitioned/', METADATA_CATALOG 'ducklake_metadata')

statement ok
USE ducklake;

# Create a table with columns for partitioning and sorting
statement ok
CREATE TABLE partitioned_sorted_tbl (part_key INTEGER, sort_key INTEGER, value VARCHAR);

# Set partitioned by part_key
statement ok
ALTER TABLE partitioned_sorted_tbl SET PARTITIONED BY (part_key);

# Set sorted by sort_key DESC (different from partition column)
statement ok
ALTER TABLE partitioned_sorted_tbl SET SORTED BY (sort_key DESC);

# Insert data with ORDER BY sort_key ASC (opposite of SET SORTED BY)
# part_key will be 0 or 1, sort_key will be the row number
statement ok
INSERT INTO partitioned_sorted_tbl (part_key, sort_key, value)
FROM range(10) t(i)
SELECT
    i % 2 AS part_key,
    i AS sort_key,
    'value' || i AS value
ORDER BY
    i ASC
;

# Verify data within partition 0 is sorted by sort_key DESC
query III
SELECT * FROM partitioned_sorted_tbl WHERE part_key = 0
----
0	8	value8
0	6	value6
0	4	value4
0	2	value2
0	0	value0

# Verify data within partition 1 is sorted by sort_key DESC
query III
SELECT * FROM partitioned_sorted_tbl WHERE part_key = 1
----
1	9	value9
1	7	value7
1	5	value5
1	3	value3
1	1	value1

# Verify files are partitioned correctly
query II
SELECT partition_id, regexp_extract(path, '.*(part_key=[0-9])[/\\].*', 1)
FROM ducklake_metadata.ducklake_data_file
ORDER BY 2
----
2	part_key=0
2	part_key=1

# Verify file pruning works when filtering by partition key
query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM partitioned_sorted_tbl WHERE part_key = 1
----
analyzed_plan	<REGEX>:.*Total Files Read: 1.*

# Test appending more data - should maintain both partitioning and sorting
statement ok
INSERT INTO partitioned_sorted_tbl (part_key, sort_key, value)
FROM range(10, 20) t(i)
SELECT
    i % 2 AS part_key,
    i AS sort_key,
    'value' || i AS value
ORDER BY
    i ASC
;

# Verify new data in partition 0 is also sorted by sort_key DESC
query III
SELECT * FROM partitioned_sorted_tbl WHERE part_key = 0 AND sort_key >= 10
----
0	18	value18
0	16	value16
0	14	value14
0	12	value12
0	10	value10

# Verify new data in partition 1 is also sorted by sort_key DESC
query III
SELECT * FROM partitioned_sorted_tbl WHERE part_key = 1 AND sort_key >= 10
----
1	19	value19
1	17	value17
1	15	value15
1	13	value13
1	11	value11
